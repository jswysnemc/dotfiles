#!/bin/bash
# clipboard-sync-ultimate
# 融合版:
# 1. X11 监听使用 clipnotify (事件驱动，低延迟)
# 2. Wayland 监听使用 Polling (轮询，高稳定性，解决回调失效问题)
# 3. 传输逻辑使用 管道 (Pipe) (解决图片/截图损坏问题)

LOG_FILE="$HOME/.local/share/clipboard-sync/clipboard-sync.log"
SELF_PATH="$(realpath "$0")"
export DISPLAY=${DISPLAY:-:0}

mkdir -p "$(dirname "$LOG_FILE")"

# -----------------------------------------------------------------------------
# 工具函数: 日志与预览
# -----------------------------------------------------------------------------

get_preview() {
    local type="$1"
    if [[ "$type" == *"image/"* ]]; then
        echo "[Binary Image: $type]"
        return
    fi

    local content
    if [[ "$2" == "wayland" ]]; then
        content=$(timeout 1s wl-paste --no-newline 2>/dev/null)
    else
        content=$(timeout 1s xclip -selection clipboard -o 2>/dev/null | tr -d '\n')
    fi

    if [[ -z "$content" ]]; then
        echo "(empty)"
        return
    fi

    local clean_content="${content//[$'\t\r\n']/ }"
    local char_len=${#content}
    local byte_len=$(echo -n "$content" | wc -c)

    if [ "$char_len" -eq "$byte_len" ]; then
        echo "'${clean_content:0:4}...'"
    else
        echo "'${clean_content:0:2}...'"
    fi
}

log() {
    local direction="$1"
    local type="$2"
    local source="$3"
    local preview=$(get_preview "$type" "$source")
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$direction] Type: $type | Content: $preview" >> "$LOG_FILE"
}

# -----------------------------------------------------------------------------
# 核心函数: 获取哈希 (带超时保护)
# -----------------------------------------------------------------------------

get_x11_hash() {
    local targets
    targets=$(timeout 0.5s xclip -selection clipboard -t TARGETS -o 2>/dev/null) || return 1

    if echo "$targets" | grep -q "image/png"; then
        local size=$(timeout 0.5s xclip -selection clipboard -t image/png -o 2>/dev/null | wc -c)
        echo "${size} image/png"
    elif echo "$targets" | grep -q "image/"; then
        local img_type=$(echo "$targets" | grep "image/" | head -1)
        local size=$(timeout 0.5s xclip -selection clipboard -t "$img_type" -o 2>/dev/null | wc -c)
        echo "${size} ${img_type}"
    elif echo "$targets" | grep -q "x-special/gnome-copied-files"; then
        local hash=$(timeout 0.5s xclip -selection clipboard -t "x-special/gnome-copied-files" -o 2>/dev/null | md5sum | cut -d' ' -f1)
        echo "${hash} x-special/gnome-copied-files"
    elif echo "$targets" | grep -q "text/uri-list"; then
        local hash=$(timeout 0.5s xclip -selection clipboard -t "text/uri-list" -o 2>/dev/null | md5sum | cut -d' ' -f1)
        echo "${hash} text/uri-list"
    else
        local hash=$(timeout 0.5s xclip -selection clipboard -o 2>/dev/null | md5sum | cut -d' ' -f1)
        echo "${hash} text/plain"
    fi
}

get_wayland_hash() {
    local types
    types=$(timeout 0.5s wl-paste --list-types 2>/dev/null) || return 1

    if echo "$types" | grep -q "image/png"; then
        local size=$(timeout 0.5s wl-paste --type image/png 2>/dev/null | wc -c)
        echo "${size} image/png"
    elif echo "$types" | grep -q "image/"; then
        local img_type=$(echo "$types" | grep "image/" | head -1)
        local size=$(timeout 0.5s wl-paste --type "$img_type" 2>/dev/null | wc -c)
        echo "${size} ${img_type}"
    elif echo "$types" | grep -q "x-special/gnome-copied-files"; then
        local hash=$(timeout 0.5s wl-paste --type "x-special/gnome-copied-files" 2>/dev/null | md5sum | cut -d' ' -f1)
        echo "${hash} x-special/gnome-copied-files"
    elif echo "$types" | grep -q "text/uri-list"; then
        local hash=$(timeout 0.5s wl-paste --type "text/uri-list" 2>/dev/null | md5sum | cut -d' ' -f1)
        echo "${hash} text/uri-list"
    else
        local hash=$(timeout 0.5s wl-paste 2>/dev/null | md5sum | cut -d' ' -f1)
        echo "${hash} text/plain"
    fi
}

# -----------------------------------------------------------------------------
# 同步执行逻辑 (Pipe传输，确保图片完整)
# -----------------------------------------------------------------------------

# 将当前 Wayland 内容同步到 X11
perform_sync_w2x() {
    local w_sig="$1"
    local w_type=${w_sig#* }

    local x_sig=$(get_x11_hash)
    local w_hash=${w_sig%% *}
    local x_hash=${x_sig%% *}

    if [[ "$w_hash" == "$x_hash" && -n "$w_hash" ]]; then
        return 0
    fi

    if [[ "$w_type" == *"image/"* ]]; then
        wl-paste --type "$w_type" 2>/dev/null | xclip -selection clipboard -t "$w_type" -in 2>/dev/null
    elif [[ "$w_type" == "x-special/gnome-copied-files" || "$w_type" == "text/uri-list" ]]; then
        wl-paste --type "$w_type" 2>/dev/null | xclip -selection clipboard -t "$w_type" -in 2>/dev/null
    else
        # 优先使用 UTF-8 编码
        local types=$(wl-paste --list-types 2>/dev/null)
        if echo "$types" | grep -q "text/plain;charset=utf-8"; then
            wl-paste --type "text/plain;charset=utf-8" 2>/dev/null | xclip -selection clipboard -in 2>/dev/null
        else
            wl-paste 2>/dev/null | xclip -selection clipboard -in 2>/dev/null
        fi
    fi
    log "Wayland -> X11" "$w_type" "wayland"
}

# 将当前 X11 内容同步到 Wayland
perform_sync_x2w() {
    local x_sig=$(get_x11_hash)
    local w_sig=$(get_wayland_hash)

    local x_hash=${x_sig%% *}
    local w_hash=${w_sig%% *}
    local x_type=${x_sig#* }

    if [[ "$x_hash" == "$w_hash" && -n "$x_hash" ]]; then
        return 0
    fi

    if [[ "$x_type" == *"image/"* ]]; then
        xclip -selection clipboard -t "$x_type" -o 2>/dev/null | wl-copy --type "$x_type" 2>/dev/null
    elif [[ "$x_type" == "x-special/gnome-copied-files" || "$x_type" == "text/uri-list" ]]; then
        xclip -selection clipboard -t "$x_type" -o 2>/dev/null | wl-copy --type "$x_type" 2>/dev/null
    else
        # 优先使用 UTF-8 编码
        local targets=$(xclip -selection clipboard -t TARGETS -o 2>/dev/null)
        if echo "$targets" | grep -q "UTF8_STRING"; then
            xclip -selection clipboard -t UTF8_STRING -o 2>/dev/null | wl-copy 2>/dev/null
        else
            xclip -selection clipboard -o 2>/dev/null | wl-copy 2>/dev/null
        fi
    fi
    log "X11 -> Wayland" "$x_type" "x11"
}

# -----------------------------------------------------------------------------
# 监听循环 (Watchers)
# -----------------------------------------------------------------------------

# 1. X11 监听器: 使用 clipnotify (事件驱动，高效)
if [[ "$1" == "--watch-x11" ]]; then
    while true; do
        clipnotify -s clipboard >/dev/null 2>&1
        sleep 0.1 # 等待写入稳定
        perform_sync_x2w
    done
    exit 0
fi

# 2. Wayland 监听器: 使用 轮询 (解决回调不触发问题)
if [[ "$1" == "--watch-wayland" ]]; then
    LAST_W_HASH=""
    while true; do
        # 仅查询 Wayland 哈希 (非常快)
        CURR_W_SIG=$(get_wayland_hash)
        CURR_W_HASH=${CURR_W_SIG%% *}

        # 只有当 Wayland 本身发生变化时，才去尝试同步
        # 这样避免了每一轮循环都去查询 X11，降低 CPU 消耗
        if [[ -n "$CURR_W_HASH" && "$CURR_W_HASH" != "$LAST_W_HASH" ]]; then
            perform_sync_w2x "$CURR_W_SIG"
            LAST_W_HASH="$CURR_W_HASH"
        fi

        sleep 0.5
    done
    exit 0
fi

# -----------------------------------------------------------------------------
# 主进程控制
# -----------------------------------------------------------------------------

# 检查依赖
for tool in wl-paste xclip clipnotify; do
    if ! command -v "$tool" >/dev/null 2>&1; then
        echo "Error: Missing dependency '$tool'" >&2
        exit 1
    fi
done

echo "Starting Clipboard Sync Ultimate..."
echo "Log: $LOG_FILE"

# 清理旧进程
pkill -f "clipboard-sync-event --watch" 2>/dev/null

# 启动 Wayland 轮询监听
"$0" --watch-wayland &
PID_WAYLAND=$!

# 启动 X11 事件监听
"$0" --watch-x11 &
PID_X11=$!

log "SYSTEM" "Service Started (Hybrid Mode)" "none"

cleanup() {
    log "SYSTEM" "Stopping..." "none"
    kill "$PID_WAYLAND" "$PID_X11" 2>/dev/null
    pkill -P "$PID_X11" clipnotify 2>/dev/null
    exit 0
}

trap cleanup SIGINT SIGTERM
wait

